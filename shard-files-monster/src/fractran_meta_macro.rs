// Meta-FRACTRAN: Macro that generates FRACTRAN macros from 71 shards

macro_rules! fractran_meta_macro {
    ($shard_count:expr, $input_file:expr) => {
        // Generate 71 FRACTRAN macros, one per shard
        macro_rules! fractran_shard_0 {
            () => { compile_error!("Shard 0 not yet generated"); }
        }
        
        // Meta-generator: creates macro for each shard
        macro_rules! generate_shard_macro {
            ($shard_id:expr, $prime:expr) => {
                paste::paste! {
                    macro_rules! [<fractran_shard_ $shard_id>] {
                        () => {
                            ShardMacro {
                                id: $shard_id,
                                prime: $prime,
                                input: $input_file,
                            }
                        };
                    }
                }
            };
        }
    };
}

// Shard macro structure (generated by meta-macro)
#[derive(Debug, Clone)]
pub struct ShardMacro {
    pub id: u64,
    pub prime: u64,
    pub input: &'static str,
}

// FRACTRAN program generator from shards
macro_rules! fractran_from_shards {
    ($($shard_id:expr => $prime:expr),*) => {
        {
            let mut program = Vec::new();
            $(
                program.push(($prime, 2u64.pow($shard_id as u32)));
            )*
            program
        }
    };
}

// Memory-mapped shard structure from FRACTRAN
#[derive(Debug, Clone)]
pub struct FractranMemoryShard {
    pub shard_id: u64,
    pub prime_mod: u64,
    pub data: Vec<u8>,
}

impl FractranMemoryShard {
    pub fn from_macro(shard: ShardMacro, data: Vec<u8>) -> Self {
        Self {
            shard_id: shard.id,
            prime_mod: shard.prime,
            data,
        }
    }
    
    pub fn to_fractran_pair(&self) -> (u64, u64) {
        (self.prime_mod, 2u64.pow(self.shard_id as u32))
    }
}

// Export macros
pub use fractran_meta_macro;
pub use fractran_from_shards;
